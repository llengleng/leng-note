(window.webpackJsonp=window.webpackJsonp||[]).push([[16],{287:function(e,t,a){"use strict";a.r(t);var s=a(13),r=Object(s.a)({},(function(){var e=this,t=e._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"其他面试题"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#其他面试题"}},[e._v("#")]),e._v(" 其他面试题")]),e._v(" "),t("h2",{attrs:{id:"说一说-cookie-sessionstorage-localstorage-区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#说一说-cookie-sessionstorage-localstorage-区别"}},[e._v("#")]),e._v(" 说一说 cookie sessionStorage localStorage 区别？")]),e._v(" "),t("h3",{attrs:{id:"解题思路"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#解题思路"}},[e._v("#")]),e._v(" 解题思路:")]),e._v(" "),t("blockquote",[t("p",[e._v("得分点: 数据存储位置、生命周期、存储大小、写入方式、数据共享、发送请求时是否携带、应用场景。")])]),e._v(" "),t("h3",{attrs:{id:"标准回答"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#标准回答"}},[e._v("#")]),e._v(" 标准回答：")]),e._v(" "),t("ol",[t("li",[e._v("Cookie、SessionStorage、 LocalStorage都是浏览器的本地存储。")]),e._v(" "),t("li",[e._v("它们的共同点：")])]),e._v(" "),t("ul",[t("li",[e._v("都是存储在浏览器本地的。")])]),e._v(" "),t("ol",{attrs:{start:"3"}},[t("li",[e._v("它们的区别：")])]),e._v(" "),t("ul",[t("li",[e._v("cookie是由服务器端写入的，而SessionStorage、 LocalStorage都是由前端写入的。")]),e._v(" "),t("li",[e._v("cookie的生命周期是由服务器端在写入的时候就设置好的，LocalStorage是写入就一直存在，除非手动清除，SessionStorage是页面关闭的时候就会自动清除。")]),e._v(" "),t("li",[e._v("cookie的存储空间比较小大概4KB，SessionStorage、 LocalStorage存储空间比较大，大概5M。")]),e._v(" "),t("li",[e._v("Cookie、SessionStorage、 LocalStorage数据共享都遵循同源原则，SessionStorage还限制必须是同一个页面。在前端给后端发送请求的时候会自动携带Cookie中的数据，但是SessionStorage、 LocalStorage不会。")]),e._v(" "),t("li",[e._v("加分回答：由于它们的以上区别，所以它们的应用场景也不同，Cookie一般用于存储登录验证信息SessionID或者token，LocalStorage常用于存储不易变动的数据，减轻服务器的压力，SessionStorage可以用来检测用户是否是刷新进入页面，如音乐播放器恢复播放进度条的功能。")])]),e._v(" "),t("h2",{attrs:{id:"说一说你对闭包的理解"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#说一说你对闭包的理解"}},[e._v("#")]),e._v(" 说一说你对闭包的理解？")]),e._v(" "),t("h3",{attrs:{id:"解题思路-2"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#解题思路-2"}},[e._v("#")]),e._v(" 解题思路:")]),e._v(" "),t("blockquote",[t("p",[e._v("得分点: 变量背包、作用域链、局部变量不销毁、函数体外访问函数的内部变量、内存泄漏、内存溢出、形成块级作用域、柯里化、构造函数中定义特权方法、Vue中数据响应式Observer。")])]),e._v(" "),t("h3",{attrs:{id:"标准回答-2"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#标准回答-2"}},[e._v("#")]),e._v(" 标准回答：")]),e._v(" "),t("p",[e._v("一个函数和词法环境的引用捆绑在一起，这样的组合就是闭包（closure）。一般就是一个函数A，return其内部的函数B，被return出去的B函数能够在外部访问A函数内部的变量，这时候就形成了一个B函数的变量背包，A函数执行结束后这个变量背包也不会被销毁，并且这个变量背包在A函数外部只能通过B函数访问。")]),e._v(" "),t("ul",[t("li",[e._v("闭包形成的原理：作用域链，当前作用域可以访问上级作用域中的变量。")]),e._v(" "),t("li",[e._v("闭包解决的问题：能够让函数作用域中的变量在函数执行结束之后不被销毁，同时也能在函数外部可以访问函数内部的局部变量。")]),e._v(" "),t("li",[e._v("闭包带来的问题：由于垃圾回收器不会将闭包中变量销毁，于是就造成了内存泄露，内存泄露积累多了就容易导致内存溢出。\n加分回答：闭包的应用，能够模仿块级作用域，能够实现柯里化，在构造函数中定义特权方法、Vue中数据响应式Observer中使用闭包等。")])]),e._v(" "),t("h2",{attrs:{id:"说一说数组去重都有哪些方法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#说一说数组去重都有哪些方法"}},[e._v("#")]),e._v(" 说一说数组去重都有哪些方法？")]),e._v(" "),t("blockquote",[t("p",[e._v("得分点 对象属性、new Set() 、indexOf、hasOwnProperty、reduce+includes、filter 标准回答 第一种方法：利用对象属性key排除重复项：遍历数组，每次判断对象中是否存在该属性，不存在就存储在新数组中，并且把数组元素作为key，设置一个值，存储在对象中，最后返回新数组。这个方法的优点是效率较高，缺点是占用了较多空间，使用的额外空间有一个查询对象和一个新的数组 第二种方法：利用Set类型数据无重复项：new 一个 Set，参数为需要去重的数组，Set 会自动删除重复的元素，再将 Set 转为数组返回。这个方法的优点是效率更高，代码简单，思路清晰，缺点是可能会有兼容性问题 第三种方法：filter+indexof 去重：这个方法和第一种方法类似，利用 Array 自带的 filter 方法，返回 arr.indexOf(num) 等于 index 的num。原理就是 indexOf 会返回最先找到的数字的索引，假设数组是 [1, 1]，在对第二个1使用 indexOf 方法时，返回的是第一个1的索引0。这个方法的优点是可以在去重的时候插入对元素的操作，可拓展性强。 第四种方法：这个方法比较巧妙，从头遍历数组，如果元素在前面出现过，则将当前元素挪到最后面，继续遍历，直到遍历完所有元素，之后将那些被挪到后面的元素抛弃。这个方法因为是直接操作数组，占用内存较少。 第五种方法：reduce +includes去重：这个方法就是利用reduce遍历和传入一个空数组作为去重后的新数组，然后内部判断新数组中是否存在当前遍历的元素，不存在就插入到新数组中。这种方法时间消耗多，内存空间也有额外占用。 方法还有很多，常用的、了解的这些就可以 加分回答 以上五个方法中，在数据低于10000条的时候没有明显的差别，高于10000条，第一种和第二种的时间消耗最少，后面三种时间消耗依次增加，由于第一种内存空间消耗比较多，且现在很多项目不再考虑低版本浏览器的兼容性问题，所以建议使用第二种去重方法，简洁方便。")])]),e._v(" "),t("h2",{attrs:{id:"说一下浏览器如何渲染页面的"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#说一下浏览器如何渲染页面的"}},[e._v("#")]),e._v(" 说一下浏览器如何渲染页面的？")]),e._v(" "),t("blockquote",[t("p",[e._v("得分点 dom树、stylesheet、布局树、分层、光栅化、合成 标准回答 浏览器拿到HTML，先将HTML转换成dom树，再将CSS样式转换成stylesheet，根据dom树和stylesheet创建布局树，对布局树进行分层，为每个图层生成绘制列表，再将图层分成图块，紧接着光栅化将图块转换成位图，最后合成绘制生成页面。 加分回答 分层的目的：避免整个页面渲染，把页面分成多个图层，尤其是动画的时候，把动画独立出一个图层，渲染时只渲染该图层就ok，transform，z-index等，浏览器会自动优化生成图层 光栅化目的：页面如果很长但是可视区很小，避免渲染非可视区的样式造成资源浪费，所以将每个图层又划分成多个小个子，当前只渲染可视区附近区域")])]),e._v(" "),t("h2",{attrs:{id:"说一说前端性能优化手段"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#说一说前端性能优化手段"}},[e._v("#")]),e._v(" 说一说前端性能优化手段？")])])}),[],!1,null,null,null);t.default=r.exports}}]);